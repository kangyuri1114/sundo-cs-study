### 6. 응용 계층

> **1. 쿠키**
>
> HTTP의 stateless한 특성을 보안화기 위한 수단
> 서버에서 생성되어 클라이언트에 저장되는 <이름, 값> 쌍 형태의 데이터

서버는 쿠키를 생성해 클라이언트로 전송하고, 클라이언트는 쿠키를 저장해 두었다가 이후 같은 서버에 요청을 보낼 때 요청 메시지에 쿠키를 포함하여 전송합니다.

| 서버 -> 클라이언트         | 클라이언트 -> 서버   |
|---------------------|---------------|
| 응답 메시지의 Set-Cookie 헤더 활용| Cookie 헤더 활용  |
|![img](https://github.com/user-attachments/assets/73903786-2881-426e-ad20-79d5021c0b6d) |  ![img_1](https://github.com/user-attachments/assets/8df58e51-c451-4918-a1cb-d85a5394c3b0) |

특정 서버로부터 쿠키를 전달받았다면, 이후 해당 서버에 요청을 보낼 때 요청 메시지에는 전달받은 쿠키를 자동으로 전송합니다.

기본적으로 <이름, 값> 쌍으로 구성되어 있지만, 대부분 쿠키 데이터에는 속성값이 포함되어 있습니다.

#### 쿠키의 속성 값

1. domain : 쿠키를 전송할 도메인을 제한합니다.
2. path : 쿠키를 전송할 경로를 제한합니다.

![img_2](https://github.com/user-attachments/assets/860c52cd-36fe-40ce-a645-96eb0dfbd1ad)


3. Expires : 명시된 시점이 지나면 삭제되어 전달되지 않습니다. 
4. Max-Age : 유효기간이 지나면 삭제되어 전달되지 않습니다. 

![img_3](https://github.com/user-attachments/assets/f89b677a-d30b-4562-98b1-32b522ca518d)

5. Secure : HTTP의 더 안전한 방식인 HTTPS를 통해서만 쿠키를 송수신하도록 합니다.
6. HttpOnly : 자바스크립트를 통한 쿠키의 접근을 제한합니다. 오직 HTTP 헤더를 주고받는 방식으로만 쿠키에 접근하도록 합니다. 

![img_4](https://github.com/user-attachments/assets/e6d8d0ad-abff-4d1f-8450-0d09abf89910)

> **2. 웹 스토리지**
>
> 쿠키 외에도 클라이언트의 상태를 추측할 수 있는 <키, 값> 쌍 형태의 정보
>

웹 브라우저 내 저장 공간으로 쿠키보다 더 큰 데이터를 저장할 수 있습니다.
쿠키는 서버로 자동 전송되지만, 웹 스토리지 정보를 자동으로 전송되지 않습니다.

- local storage : 별도로 삭제하지 않으면 영구 저장 가능한 정보
- session storage :  세션이 유지되는 동안 유지되는 정보


> **3. 캐시**
>
> 응답받은 자원의 사본을 임시 저장해 불필요한 대역폭 낭비와 응답 지연을 방지하는 기술
>

![img_5](https://github.com/user-attachments/assets/0145b5c1-641e-489b-a162-564b4a9685d1)


캐시는 클라이언트(웹 브라우저)에 저장(전용 캐시)되기도 하고, 클라이언트와 서버 사이에 위치한 중간 서버에 저장(공용 캐시)되기도 합니다.

캐시된 데이터에는 캐시 데이터와 원본 데이터 간의 일관성 유지를 위해 유효기간이 설정되어 있습니다.
사본 데이터와 원본 데이터 간 유사 정도를 캐시 신선도 (cache freshness)라고 합니다. 

- Expires 헤더 : 캐시한 데이터의 만료 날짜
- Max-Age 값 : 캐시하여 사용 가능한 초 단위 시간

![img_6](https://github.com/user-attachments/assets/2d2d5dc8-ccf0-45ea-894f-514443b80deb)


원본 데이터가 변경된 경우만 새로운 자원을 응답받는 것이 좋기 때문에 클라이언트는 캐시된 자원의 유효기간이 만료되었을 때, 서버에게 원본 자원이 변경된 적이 있는지 질의합니다. 

- If-Modified-Since 헤더 : 클라이언트가 **날짜를 기반**으로 원본 자원의 변경 여부를 묻는 헤더 (날짜, 시각)

![img_7](https://github.com/user-attachments/assets/697366cd-7259-4cce-987f-5abb28512199)

1) 서버가 요청받은 자원이 변경된 경우
서버가 200과 함께 새 자원 반환

2) 서버가 요청받은 자원이 변경되지 않은 경우
메시지 본문 없이 **304(Not Modified)** 반환 -> 클라이언트에서는 캐시된 자원을 사용 

3) 서버가 요청받은 자원이 삭제된 경우
404(Not Found)로 자원이 존재하지 않음을 알림
![img_8](https://github.com/user-attachments/assets/2ce7e0ed-4b49-4bff-8d8b-06016ac12a72)


- Etag (Entity Tag) : 자원의 버전을 식별하기 위한 정보
- If-None-Match : 요청할 자원에 대한 Etag 값 명시 

자원이 변경될 때마다 자원의 버전을 식별하는 Etag 값이 변경됩니다. 

1) 서버가 요청받은 자원이 변경된 경우
서버가 200과 함께 새 자원 반환

2) 서버가 요청받은 자원이 변경되지 않은 경우
메시지 본문 없이 **304(Not Modified)** 반환 -> 클라이언트에서는 캐시된 자원을 사용

3) 서버가 요청받은 자원이 삭제된 경우
404(Not Found)로 자원이 존재하지 않음을 알림

![img_9](https://github.com/user-attachments/assets/5591c81c-5e63-4cb3-8d49-7c806178358f)



> **4. 콘텐츠 협상**
> 
> 같은 자원에 대해 할 수 있는 여러 표현 중 클라이언트가 가장 적합한 자원의 표현을 제공하는 기술
> 

자원의 다양한 표현 중 클라이언트가 선호하는 자원의 표현을 콘텐츠 협상 헤더를 통해 서버에게 전송해 서버는 클라이언트가 요청한 자원의 표현을 응답

- Accept : 선호하는 미디어 타입을 나타내는 헤더
- Accept-Language : 선호하는 언어를 나타내는 헤더
- Accept-Encoding : 선호하는 인코딩 방식을 나타내는 헤더


![img_10](https://github.com/user-attachments/assets/96457628-1b01-4ff7-9ec4-15d289a91f29)



콘텐츠 협상 관련 헤더 q값으로 우선순위를 반영할 수 있습니다. 
0부터 1까지의 표현 범위 중 생략되었을 때는 1이 되고 값이 클수록 우선순위가 높아집니다. 


![img_11](https://github.com/user-attachments/assets/75482243-c233-4689-add7-d97562c89dbe)


한국어 > 영어 순으로 선호, HTML > XML > 일반 텍스트 순서로 선호

> **5. 보안 SSL/TLS와 HTTPS**
> 
> SSL과 TLS은 인증과 암호화를 수행하는 프로토콜, TLS는 SSL을 계승
>

TLS 기반 HTTPS 메시지 송수신 단계
1. TCP 3way handshake
2. TLS handshake
3. 메시지 송수신

TLS 핸드쉐이크를 통해 암호화 통신을 위한 키 생성 및 교환을 할 수 있고, 
인증서 송수신과 검증이 이루어질 수 있습니다. 

|3way handshake| 암호화 및 복호화 |
|---|-----------|
|![img_12](https://github.com/user-attachments/assets/766c59ce-92a4-4d60-b548-b16aabe737c6)|![img_13](https://github.com/user-attachments/assets/068f618d-ef82-4e8e-b859-e1a4ec0a2b2b)|

TLS handshake 과정에서 두 호스트만 알아야 하는 key가 생성됩니다. 

클라이언트는 사용가능한 암호화 알고리즘과 해시 함수를 서버에 알리기 위해 ClientHello 메시지에 다음과 같은 형태의 정보를 포함해 전송합니다 
이를 암호 suite 라고 합니다.


![img_14](https://github.com/user-attachments/assets/5081d924-3c17-4f27-b22b-f01e5e38c2fa)



TLS 핸드셰이크에서는 암호화 통신을 위한 키 교환도 이루어지지만, 인증서의 송수신과 검증도 이루어질 수 있습니다. 

인증서(certificate)는 클라이언트가 통신을 원하는 주체가 맞음을 입증하기 위한 정보입니다. 
제3의 기관에서 이를 입증해야 하는데, 인증서를 발급하고 검증하는 제3의 인증기관(CA)가 있습니다.

- Certificate 메시지 : 인증서 서명 값 등 인증서 내용
- Cerfiticate Verify 메시지 : 인증서의 올바른 내용인지 검증하기 위한 메시지 


![img_15](https://github.com/user-attachments/assets/1365433f-2cc9-4b56-baad-d397f3f26272)



서버와 클라이언트가 마지막 Finished 메시지를 주고받고 이후 TLS 핸드셰이크를 통해 얻어낸 키를 기반으로 암호화된 데이터(Application Data)를 주고 받습니다.

